# 位掩码

> 原文:[https://www.learn-c.org/en/Bitmasks](https://www.learn-c.org/en/Bitmasks)

* * *

位屏蔽只是将数据真正存储为位的过程，而不是将其存储为 char/int/float。它对于紧凑高效地存储某些类型的数据非常有用。

位屏蔽的思想基于布尔逻辑。对于那些不熟悉的人来说，布尔逻辑是通过逻辑运算(以 0 和 1 作为参数)对“真”(1)和“假”(0)的操作。我们关注以下操作:

*   不是 a -最终值与输入值相反(1 -> 0，0 -> 1)
*   a 和 b——如果两个值都为 1，则最终值为 1，否则最终值为 0
*   a 或 b——如果任一值为 1，则最终值为 1，否则最终值为 0
*   a XOR b——如果一个值为 1，另一个值为 0，则最终值为 1，否则最终值为 0

在计算中，这些真/假值之一是一个*位*。C 语言中的原语(`int`、`float`等)由一定数量的位组成，其中该数量是 8 的倍数。例如，`int`的大小至少可以是 16 位，而`char`可以是 8 位。8 位通常被称为一个*字节*。c 保证某些原语的大小至少是某个字节数。C11 中`stdint.h`的引入允许程序员指定正好是某个字节数的整数类型，这在使用掩码时非常有用。

设置标志时经常使用位掩码。标志是可以处于两种状态的值，例如“开/关”和“移动/静止”。

### 设置位 n

设置位`n`就像对存储变量的值与值`2^n`进行“或”运算一样简单。

`storage |= 1 << n;`

例如，这里是位 3 的设置，其中`storage`是一个字符(8 位):

`01000010 OR 00001000 == 01001010`

`2^n`逻辑将“1”值放在掩码本身的适当位，允许访问存储变量中的相同位。

### 清零位 n

清除位`n`是存储变量的值与值`2^n`的倒数(非)进行 and 运算的结果:

`storage &= ~(1 << n);`

这又是一个例子:

`01001010 AND 11110111 == 01000010`

### 翻转位 n

翻转位`n`是存储变量的值与`2^n`异或的结果:

`storage ^= 1 << n;`

`01000010 01001010 XOR XOR 00001000 00001000 == == 01001010 01000010`

### 检查第 n 位

检查一个位是将`2^n`的值与位存储器进行“与”运算:

`bit = storage & (1 << n);`

`01000010 01001010 AND AND 00001000 00001000 == == 00000000 00001000`

## 锻炼

使用位掩码来操作一些标志。